<!DOCTYPE html>
<html>
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>TITAN V1</title>
</head>
<body>
  
<link rel="stylesheet" href=/css/style.css>


<div class="wrapper">

<header>
  <h1><a href="/">Savo's Site</a></h1>
</header>

<nav>
<div class="flex-container">

<div class="navbutton"><a href="/about-me/">About Me</a></div>
<div class="dropdown">
	<a href="/projects/">Projects</a>
	<div class="dropdown-content">
		<a href="/projects/academic/">Academic</a>
		<a href="/projects/extracurricular/">Extracurricular</a>
		<a href="/projects/personal/">Personal</a>
		<a href="/projects/work/">Work</a>
	</div>
</div>
<div class="navbutton"><a href="/publications/">Publications</a></div>
<div class="navbutton"><a href="/work-experience/">Employment</a></div>
<div class="navbutton"><a href="/volunteering/">Volunteering</a></div>
<div class="navbutton"><a href="/contact/">Contact</a></div>

<div>
</nav>


<ul class="breadcrumbs">
    <li class="breadcrumbs"><a class="subtitle" href="/">Home</a></li>
                
                    
            		 	      <li class="breadcrumbs"><a class="subtitle" href="/projects">Projects</a></li>
            		    
				        
                
                    
            		 	      <li class="breadcrumbs"><a class="subtitle" href="/projects/extracurricular">Extracurricular Projects</a></li>
            		    
				        <li class="breadcrumbs"><a class="subtitle" href="/projects/extracurricular/titan-v1">TITAN V1</a></li></ul>



	
	<main>
	<section class="mainIntro">
  



	<h1>TITAN V1</h1>
	<div class="introLine"></div>
	<div class="subtitle"><strong>Last Modified:</strong> Thursday, Feb 10, 2022</div>
	<div class="subtitle"><strong>Status:</strong> Completed, Revised</div>

	
		<div class="subtitle"><strong>Period:</strong> May 2019 - August 2019</div>
	

	<div class="subtitle"><strong>Client:</strong> HPVDT</div> 
	

	<div class="subtitle"><strong>Tags:</strong> <a href="/tags/eagle">EAGLE</a> <a href="/tags/embedded">embedded</a> <a href="/tags/hpvdt">HPVDT</a> <a href="/tags/python">python</a> <a href="/tags/rpi">rpi</a> </div>

	<div class="introLine"></div>

 


  </section>

  <section class="mainContent">
  <h1 id="overview">Overview</h1>
<p>For our new entry to the World Human Powered Speed Competition (WHPSC) in 2019, TITAN, our team wanted a new video system
for the vehicle. This system is vital because it is the <strong>only</strong> way our riders can know what is outside and steer because
we do not have normal windows - primarily to improve our aerodynamic performance. Not only was the system meant to provide
a live video feed of the surroundings, but also overlay the feed with data about the bike&rsquo;s state, namely speed.</p>
<p>This system was meant to be an upgrade from the system used on our previous vehicle, Eta Prime. The main changes were the
transition to a digital video system based around Raspberry Pis and adding an additional rear facing camera for the rear
rider.</p>
<p>Although the hardware was completed in time for the competition, I was unable to thoroughly test it. Some issues were
encountered so the crew at the competition reverted to the Eta Prime video system since I was not present to remedy these
problems myself.</p>
<h2 id="requirements">Requirements</h2>
<ul>
<li>Have three displays, each running a separate video feed
<ul>
<li>One front facing &ldquo;main&rdquo; display for front rider</li>
<li>One rear facing &ldquo;secondary&rdquo; display for rear rider</li>
<li>One front facing &ldquo;spare&rdquo; display as a redundant video feed for the front rider <em>(does not display bike data)</em></li>
</ul>
</li>
<li>Gather and relay the following <em>critical</em> data to the riders
<ul>
<li>Bike speed</li>
<li>Distance travelled</li>
<li>Cadence (rate of pedalling) per rider</li>
<li>Battery level</li>
</ul>
</li>
<li><strong>Video feed must be stable and run at a minimum of 30 frames per second</strong></li>
</ul>
<h2 id="objectives">Objectives</h2>
<ul>
<li>Use digital cameras</li>
<li>Gather and relay the following data to the riders
<ul>
<li>Rider heart rate</li>
<li>Ambient temperature and humidity</li>
</ul>
</li>
<li>Stream data to chase vehicle</li>
<li>Record video feed</li>
<li>Log all collected data</li>
<li>Inform users on the estimated &ldquo;performance&rdquo; of the run relative to expectations
<ul>
<li>If the conditions were favourable inform the riders we were expecting a performance over &ldquo;100%&rdquo; so they would know to try their best</li>
<li>Likewise warn the riders if the run is unlikely to be in our favour and spare their energy</li>
</ul>
</li>
</ul>
<h2 id="takeaways">Takeaways</h2>
<p>Testing was the critical failure on my part in this project. Had there been more time I likely would have caught the issues
and tried to correct them before competition. I compiled feedback from the crew regarding both issues and suggestions that
they felt would improve this system and others in the future.</p>
<p>As for personal takeaways, this project was my first large project that used Python, so I learned a lot about it. I found it
quite nice to use, if a bit fussy due to its structured whitespace. My only issue was that due to the nature of an
interpreted language, I had issues where I was calling functions incorrectly but was only told so when I ran into them, one
by one.</p>
<p>It also was my first project that made use of a microcomputer, the Raspberry Pi. I had used one before, but it was mostly a
curiosity rather than a proper tool in my eyes. In this project I came to learn about how to interface hardware with it and
some of the cool features it had that could offload some complicated processing from microcontrollers. I also learned to
respect some of its limitations such as its latency and slow output control.</p>
<p>I&rsquo;m looking forward to revising the system and using my gained experience in other pursuits both for the team and my own.</p>
<h1 id="detailed-report">Detailed Report</h1>
<p>For our high performance speed bikes we pioneered the use of a video feed in place of a conventional window to see out of
our vehicles. This approach provides us with a couple of advantages, namely improving our aerodynamics by allowing more
recumbent riding positions for our riders (closer to laying down than sitting) which decreases our frontal cross section,
and the removal of a window removes numerous seams that could contribute to disturbing laminar flow over the remainder of
the fairing increasing drag. Thanks to optimizations like this, we are able to have <strong>our speed bikes exceed speeds of 120 km/h!</strong>
Eta Prime currently holds our record at a hair over 130 km/h!</p>
<p>In the place of a window a camera in a mast is placed outside the vehicle and the camera&rsquo;s view is relayed to a display
inside the vehicle for the rider(s). On TITAN the mast is the white protrusion midway along the top, Eta Prime the black
mast towards the end along the top.</p>
<figure>
<img src="/images/titan-at-competition.jpg">
<figcaption>TITAN and our crew at the WHPSC 2019</figcaption>
</figure>
<figure>
<img src="/images/eta-prime-racing.jpg">
<figcaption>Eta Prime racing at WHPSC 2017 or 2018</figcaption>
</figure>
<p>This camera is vital as it is the only way for the rider(s) to see their surroundings. Should it fail, the rider(s) only
have a few seconds of stability (even aided by radio instruction) before they will inevitably crash following a vision
outage. In addition to the necessity of the system to operate reliably for our speed bikes to compete, they need to be
responsive enough to allow for rapid corrections and to prevent rider discomfort.</p>
<p>The vision system is also used to relay information about the vehicle to the riders, like speed, using overlays on the video
feeds. This makes it convenient for the rider(s) to quickly check how the ride is going since they do not have to shift
their focus from the screen to do so.</p>
<p><strong>Unlike all our previous speed bikes, TITAN is a <em>tandem</em> vehicle.</strong> The riders sit back to back, with one facing forwards
and the other backwards. The team thought it would be wise to add an additional screen to the usual &ldquo;main&rdquo; and &ldquo;spare&rdquo;
arrangement, for the rear rider. This rear screen would receive a video from a rear facing camera in the hopes of preventing
potential discomforts of them moving &ldquo;backwards&rdquo;.</p>
<h2 id="overall-system-design">Overall System Design</h2>
<p>With the system&rsquo;s purpose outlined to me, the only other remaining suggestion/guidance I was given related to the design was
to use Raspberry Pis (RPi) and Raspberry Pi Cameras (PiCam) as the foundation of the system. Since they had used these before
successfully with Eta Prime.</p>
<p>At the time, the RPi Model 3B+&rsquo;s were the newest version available, so I purchased these as well as several cameras for
testing. Each RPi could only connect to a single camera and a single display, so I had to use three for the whole system.
This made it harder for me to distribute data around the system since I was used to only having one or two microcontrollers
in a system, but not three microcomputers with a yet unknown number of microcontrollers.</p>
<p>I decided to put a single STM32 microcontroller in the centre of the system to serve as a router of information in the
system. It would communicate with the two data displaying systems digitally so data could be quickly exchanged as well as
making use of its other hardware to collect some data itself to provide to the system.</p>
<p>In the end the basic block diagram was drawn up to be the following. My choices will be explained in greater detail in the
sections that follow.</p>
<figure>
<img src="/images/titan-connection-diagram.png">
<figcaption>A diagram showing the connections present in TITAN</figcaption>
</figure>
<h3 id="raspberry-pis-and-pi-cams">Raspberry Pis and Pi Cams</h3>
<p>These were mainly used because of the recommendation to use them from the project lead. Even without his recommendation, I
probably would have ended up using RPis (if not the PiCams as well) given their ease of use and wealth of community support.
The purpose of the RPis was primarily to take the video feed from the cameras and display it through their HDMI output,
overlaying the feed with information it collects from the system or itself.</p>
<p>This community of people also using their RPis for similar purposes was immensely useful for me to refer to their work and
try to implement it in this project, notably with the ANT libraries used to collect biometric data from the riders' devices.</p>
<h3 id="displays">Displays</h3>
<p>These were generic LCD panels and driver boards one can purchase online. Our primary concerns when purchasing these were
size, resolution, refresh rate, and cost in roughly descending order of importance. I did not handle purchasing the ones we
used. All that I really cared about was their supply voltage and that they had support for HDMI.</p>
<p>All the displays ordered had HDMI support and I found through testing that they had built in voltage regulators that could
accept the entire operating voltage of our selected batteries. This meant I could simply connect the battery to the displays
and they would work, no intermediate regulator needed.</p>
<h3 id="batteries">Batteries</h3>
<p>The project manager requested that I design the system to run off
<a href="https://en.wikipedia.org/wiki/Lithium_iron_phosphate_battery">LiFePO4 chemistry-based batteries</a> instead of the more
conventional Li-ion variety. His reasoning for the request was primarily that these batteries fail in less catastrophic ways
and he would like to ensure the safety of the rider(s) as much as possible in the enclosed fairing.</p>
<p>This required no effort for me to accodate in the design since all systems directly supplied by the 11.1V Li-ions we
previously used, would also accept the 9.9V LiFePO4s I selected.</p>
<h3 id="microcontroller">Microcontroller</h3>
<p>The microcontroller&rsquo;s purpose is to collect and distribute data about TITAN as needed. The microcontroller I selected to use
in TITAN was the STM32F103C8B. I had been playing with some development boards for these for some time, and was comfortable
using them. They are more powerful than most of their ATmega counterparts used in Arduino boards. The feature that really
sealed the deal for me is that the STM32 has not one, but <em>three</em> hardware UART serial ports which is perfect for this
system. One line to each of the RPis that need to exchange data, and the third to the serial based GPS module.</p>
<p>Using a microcontroller in the system is also helpful for improving the real-time data collection performance of the system.
The nature of microcomputers leaves them pretty slow to reacting to external stimuli and the RPis are no exception, the
STM32 however like most microcontrollers is not running the overhead of an operating system and is thus more responsive,
this is vital to keep track of the wheel&rsquo;s speed which has the encoder pulse every few milliseconds at top speed.</p>
<h3 id="sensors">Sensors</h3>
<p>There was a lot of types of data collected on TITAN, I&rsquo;ll be listing the hardware I used and what data it gathered. They all
connect to the STM32 with the exception of the ANT+ module which is placed in the rear RPi since it needs a USB connection.
It goes in the rear so if data collection with the dongle crashes the rear screen it does not lead to a critical failure for
the main screen.</p>
<ul>
<li>Resistor voltage dividers
<ul>
<li>Battery levels - Used to divide the different battery voltages down to safe levels for the STM32 to measure</li>
</ul>
</li>
<li>DHT22 (Digital Humidity and Temperature)
<ul>
<li>Temperature in vehicle</li>
<li>Humidity in vehicle</li>
</ul>
</li>
<li>Optical Encoder
<ul>
<li>Wheel-based speed - The period between pulses provides the rotational rate of the wheel</li>
<li>Wheel-based distance - The number of rotations is counted and used to estimate the distance travelled</li>
</ul>
</li>
<li>GPS
<ul>
<li>Location - Not super useful during rides but useful in run analysis</li>
<li>GPS-based speed - A redundant speed value in the event the encoder is not acting correctly</li>
<li>GPS-based distance - Using the current location an estimate can be found for how far TITAN has gone, and how much remains to go</li>
</ul>
</li>
<li>ANT+ Dongle (USB connection to rear RPi)
<ul>
<li>Cadence - Both riders have ANT+ power pedals that broadcast this</li>
<li>Power - Both riders' power pedals also broadcast this</li>
<li>Heart Rates - Both riders wear heart rate monitors that broadcast this</li>
</ul>
</li>
</ul>
<h3 id="telemetry">Telemetry</h3>
<p>The system was designed to accommodate an nRF24 transceiver for communication. I had purchases a few with the intent to
start using them in our projects, starting with TITAN. They used SPI to communicate at 3.3V so they were perfect to control
with an RPi.</p>
<p>I put this to be part of the rear system because it would be closer to the radio transparent portion of the tail made of
white fibre glass. If it were more central in TITAN, the carbon fibre that composed most of the fairing would prevent the
signal from escaping.</p>
<h2 id="hardware-design">Hardware Design</h2>
<p>With the parts selected I moved on to designing the actual circuit. Since I made use of modules, there was very little other
than connections between them on the board, with the exception of the 5V regulator and the resistor dividers for monitoring
battery levels.</p>
<p><em>TITAN was designed in EAGLE, the files have only been imported into KiCAD to generate the figures related to the circuitry.</em></p>
<figure>
<img src="/images/titan-schematic.svg">
<figcaption>The completed schematic for TITAN (PDF version: <a href="/pdf/titan-v1.pdf">Colour</a> / <a href="/pdf/titan-v1-BW.pdf">BW</a>)</figcaption>
</figure>
<p>The largest difficulty with this circuit was determining how to make the same board usable for all three roles since I did
not want to design or pay for three separate designs. To achieve this I used two solder jumpers, SJ1 and SJ2 to route a
signal to either the RPi (for the rear) or the battery status LEDs (for the redundant front system).</p>
<p>The 5V regulator was selected by me, however another team member wanted to try designing circuits and learning EAGLE so I
had them prepare its schematic and layout.</p>
<p>I used USB connectors for inter-board connections since USB cables are cheap and durable, and have the four connectors I
needed between the boards. There is an Ethernet port used to connect to an off-board nRF24 module if needed (USB did not
offer enough connectors for this).</p>
<h2 id="layout">Layout</h2>
<p>The layout was similarly straight forward to the circuit design. The boards were designed to be taped down in TITAN so there
was no need for any mounting bolt holes. Since all the modules were fairly bulky the board was large but sparsely populated
except for the voltage regulator corner. The final board was about 100mm by 81mm.</p>
<figure>
<img src="/images/titan-v1-combined-layout.png">
<figcaption>The overall layout of the board</figcaption>
</figure>
<p>The voltage regulator which occupies the bottom left corner was laid out by my teammate under my supervision. I laid out the
rest of the board myself. I added some guiding text for soldering SJ1 and SJ2 to help when we would assemble the system.</p>
<figure>
<img src="/images/titan-v1-top-layout.png">
<figcaption>The layout of the top side</figcaption>
</figure>
<p>The majority of traces are on the top, the bottom was reserved mostly for a ground plane.</p>
<figure>
<img src="/images/titan-v1-bottom-layout.png">
<figcaption>The layout of the bottom side</figcaption>
</figure>
<h2 id="assembly">Assembly</h2>
<p>Assembly of the boards was pretty simple thanks to the use of only through-hole components and lots of space between most
parts of the board which let me work comfortably.</p>
<p>The main board is obvious in function due to the modules mounted. The GPS had an antenna that came off it for better
reception, but I removed it for the photo.</p>
<figure>
<img src="/images/titan-v1-main-assembled.jpg">
<figcaption>Assembled board for main display system</figcaption>
</figure>
<p>For the rear module I did not bother soldering the connectors for the nRF24 modules because I had recognized at this point
that I would be unable to get telemetry to work in time for the competition.</p>
<figure>
<img src="/images/titan-v1-rear-assembled.jpg">
<figcaption>Assembled board for rear display system</figcaption>
</figure>
<p>Since I did not solder the nRF24 connectors on the rear board, the only difference between the rear system&rsquo;s board and the
spare/redundant one is the positions of SJ1 and SJ2.</p>
<figure>
<img src="/images/titan-v1-spare-assembled.jpg">
<figcaption>Assembled board for spare display system</figcaption>
</figure>
<h2 id="coding">Coding</h2>
<p>There were two sets of code needed for TITAN. One set of code for the microcontroller primarily written in C++ using the
Arduino IDE and another set to run on the RPis written in Python.</p>
<h3 id="microcontroller-firmware">Microcontroller Firmware</h3>
<p>The microcontroller firmware was written in C++ using the Arduino IDE. The firmware on it has two main purposes: relay data
between the RPis and monitor its sensors. The main loop of code alternates between these duties forever.</p>
<h4 id="collecting-sensor-data">Collecting Sensor Data</h4>
<p>The microcontroller collects the data it is responsible for in different ways. It collects the level of batteries, and the
humidity and temperature in the vehicle periodically every few seconds since these are not rapidly changing quantities. The
GPS data is updated as it becomes available from the GPS module. The optical encoder handler is connected to an interrupt
so as to not miss any encoder pulses.</p>
<p>For the GPS and DHT module, I made use of freely available libraries for that hardware. This greatly accelerated the
development of my code for these sensors since they had already handled the majority of the work. Since it was code used by
countless others it was also more reliable than what I probably would have written from scratch.</p>
<p>All the sensors and their implementations were tested unit-wise on their own before I combined them into this firmware.</p>
<h4 id="battery-monitoring">Battery Monitoring</h4>
<p>Of the four data streams I had to prepare, the <strong>most challenging was the battery monitoring one</strong>. For the GPS and DHT I used
their libraries, so it was a trivial matter of calling the right functions. For the encoder I just incremented a counter and
converted a period into rotation rate, grade school concepts really.</p>
<p>Monitoring the batteries was more difficult though since this needed some more complex processing and there wasn&rsquo;t a library
I could just drop in. First there was the obvious issue of converting an analog-to-digital (ADC) reading to an actual voltage,
since the ADC return an integer between 0 and 4095, with 4095 corresponding to a reading matching the reference voltage
supplied (roughly 3.3V). This conversion would then be compounded by the voltage division for each battery, that would vary
slightly across the three dividers due to manufacturing tolerances. This needed me to calibrate the readings to a known
voltage and store them on the chip. My final code for this looked something like:</p>
<pre><code>reading = float(analogRead(FBPin));   // Read ADC
reading = reading * divFactor;        // Multiply by resistor division factor to get the actual input
reading = reading / readingToV;       // Divide by constant to convert the ADC steps to actual volts
</code></pre><p>Knowing the battery&rsquo;s true voltage wasn&rsquo;t enought to determin the battery level since the voltage of the battery <em>does not</em>
vary linearly with charge level. Each different battery chemistry has its own characteristic discharge curve. The discharge
curve of an LiFePO4 battery I used is described <a href="https://www.solacity.com/how-to-keep-lifepo4-lithium-ion-batteries-happy/">here</a>.
Note: the batteries referred to in the article use four (4) cells in series, the ones I was using only had three (3) so my
voltages were all going to be 3/4 that of what was described there at the same charge level.</p>
<figure>
<img src="/images/titan-v1-LiFePO4-discharging.png">
<figcaption>Discharge curve for a 4S LiFePO4 battery</figcaption>
</figure>
<p>To convert a voltage to a charge level, I would fit the voltage reading to the curve using linear interpolation between a
set of key points.</p>
<pre><code>const byte level[] = {100, 99, 90, 70, 40, 30, 20, 17, 14, 9, 0}; // Percentages linked to voltages
const float voltage[] = {10.2, 10.05, 9.975, 9.9, 9.825, 9.75, 9.675, 9.6, 9.375, 9, 7.5}; // Voltages

// Run though set point from top to bottom
for (byte i = 1; i &lt;= 11; i++) {
  if (reading &gt; voltage[i]) {
    // If the reading is in the region
    float temp = 0; // Used in calculations

    // Linear interpolation formula
    temp = (reading - voltage[i]) * float(level[i - 1] - level[i]);
    temp /= float(voltage[i - 1] - voltage[i]);
    temp += level[i];

    reading = temp; // Stores the result in the reading variable
    break;
  }
}
reading = constrain(reading, 0, 100); // Constrain it to reasonable values

/* Other code */ 

return (reading);
</code></pre><h4 id="communication-with-rpis">Communication with RPis</h4>
<p>Communication with the RPis was handled over a dedicated serial line for each. The general flow to communication is the RPi
sending a message to the STM32, and then the STM32 responds accordingly. <strong>The STM32 <em>never</em> initiates an exchange!</strong> The
structure of the message received by the STM32 followed this format:</p>
<blockquote>
<p><strong>1 character</strong> - Message type (capital letters are for sending data, lowercase for requesting data)</p>
<p><strong>1 character</strong> - Data length, <em><strong>n</strong></em> <em>(only if the RPi is sending data)</em></p>
<p><strong><em>n</em> bytes</strong> - Data to STM32 <em>(if the RPi is sending data)</em></p>
</blockquote>
<p>If the RPi is requesting data for itself, it will simply send a lowercase letter for that field, e.g. &ldquo;s&rdquo; for speed. If it
has data it wants to impart on the STM32 (to pass on to the other RPi), like the ANT+ data, it will start with a capital and
be followed by the data length and data itself. E.g. &ldquo;D!55&rdquo; would be used to set the right cadence (D) as &ldquo;55&rdquo; which is 2
characters long (&quot;!&quot; has the ASCII code of 33, but I add/subtract 31 to the lengths to keep length characters printable
since the first printable character is space, &quot; &ldquo;, at 32).</p>
<p>When the STM32 is responding with data to a request, it replies with just the data length and data itself (<em>no leading
message type character</em>).</p>
<p>The reason I used a data length character as part of messages, rather than a fixed length or delimiting character to
communicate message length is because it allows for greater flexibility than a fixed length, and it doesn&rsquo;t risk a
delimiting character randomly occurring in exchanged data, misleading the RPi or STM32.</p>
<h3 id="raspberry-pi-code">Raspberry Pi Code</h3>
<p>Unlike the STM32, the code for the RPis was written entirely in Python. I had a basis to work off of given the work done for
Eta Prime, however I reworked much if it for various reasons. The main reasons for this refactoring were:</p>
<ul>
<li>Different hardware configuration (Eta Prime did not have a microcontroller to help with data collection)</li>
<li>Different system needs, namely to share data across multiple RPis</li>
<li>Migrating code between Python 2 and 3</li>
</ul>
<h4 id="camera-feed">Camera Feed</h4>
<p>To put the camera feed onscreen and have it recorded was actually pretty simple and accomplished in less than a dozen lines
of code thanks to the work of the Raspberry Pi Foundation.</p>
<pre><code>camera = picamera.PiCamera()
camera.resolution = (self.VIDEO_WIDTH, self.VIDEO_HEIGHT)
camera.framerate = self.FRAMERATE
camera.brightness = self.BRIGHTNESS
self.camera = camera
self.camera.start_preview()

# Setup recording file
self.RECORDING = recording # Record if recording or not
if recording:
    video_title = &quot;{}.h264&quot;.format(time.strftime('%y%m%d-%H:%M:%S', time.localtime()))
    self.video_title = '/home/pi/Videos/recording-' + video_title
    self.camera.start_recording(self.video_title)
</code></pre><p>This code would put the video feed over the entire screen as a &ldquo;preview&rdquo;, and start recording it to a fill if desired. The
settings we could manage were a stable 720p HD video, at 60 frames per second.</p>
<h4 id="overlay">Overlay</h4>
<p>The overlay code needed a decent amount of rework, since a core library it depended on was written in Python 2. The library
was specifically used to create the overlay image with all the data for the riders. Initially I wanted to replace it with
something similar but capable of running in Python 3, however I was unable to find a suitable alternative at the time.
<strong>So instead I opted to run the entire system in Python 2 instead.</strong></p>
<p>Once I had the system working, I could produce a text overlay pretty simply. I would just place text boxes around the screen
as I wanted and fill them with the text I desired with some basic properties defined. These text boxes were actually drawn
on a temporary canvas/image, &ldquo;img&rdquo;, initially.</p>
<pre><code>font = ImageFont.truetype(&quot;../res/consola.ttf&quot;, size)
draw = ImageDraw.Draw(self.img)
draw.text(position, text, color, font)
</code></pre><p>Once I was done drawing all the text I wanted on the canvas I would update the overlay with this canvas simply with:</p>
<pre><code>self.overlay.update(self.img.tobytes())
</code></pre><h4 id="communication-with-stm32">Communication with STM32</h4>
<p>Communication protocol with the STM32 was outlined briefly in the STM32&rsquo;s <a href="./#communication-with-rpis">section on this</a>. The
only thing worth mentioning on the RPi side of things is that the RPi&rsquo;s block (wait) the program until a response is
received following a request. This is why the STM32 doesn&rsquo;t need to specify what its response is for, the RPi already knows.</p>
<h4 id="ant">ANT+</h4>
<p>ANT+ was where a sizable chunk of my efforts went into. I found the amptly named &ldquo;python-ant&rdquo; library online and it
supported operation on the RPi. Not only that but it had examples for a heart rate monitor and power pedal, the exact two
devices I needed to operate!</p>
<p>I started by starting the network and then connecting to the devices using the USB dongle. Most of this was copied directly
from the examples provided with the code.</p>
<pre><code>from ant.core import driver
from ant.core.node import Node, Network, ChannelID
from ant.core.constants import NETWORK_KEY_ANT_PLUS, NETWORK_NUMBER_PUBLIC
from ant.plus.power import *
from ant.plus.heartrate import *

device = driver.USB2Driver(log=None, debug=False, idProduct=0x1008)
antnode = Node(device)
antnode.start()
network = Network(key=NETWORK_KEY_ANT_PLUS, name='N:ANT+')
antnode.setNetworkKey(NETWORK_NUMBER_PUBLIC, network)

...

frontPWR.open(frontPedals, ANT_TIMEOUT)
print(&quot;Connecting front pedals&quot;)

frontHRM.open(frontHRM, ANT_TIMEOUT)
print(&quot;Connecting front HRM&quot;)

</code></pre><p>Working with these examples I looked at how they worked and gained a bit of understanding about Python callbacks since they
are an integral part of how this library worked. Eventually I prepared my own, so that when a heart rate or power value was
registered, the system would share it immediately with the rest of TITAN.</p>
<pre><code># Functions for broadcasting data
def front_power_data(eventCount, pedalDiff, pedalPowerRatio, cadence, accumPower, instantPower):
    microController.sendData('E', str(instantPower))
    microController.sendData('C', str(cadence))
def front_heartrate_data(computed_heartrate, event_time_ms, rr_interval_ms):
    microController.sendData('A', str(computed_heartrate))

...

frontHRM = HeartRate(antnode, network, callbacks = {'onDevicePaired': hr_device_found, 'onHeartRateData': front_heartrate_data})
frontPWR = BicyclePower(antnode, network, callbacks = {'onDevicePaired': power_device_found, 'onPowerData': front_power_data})
</code></pre><p>All this was not peachy though. I had to make some adjustments to the library. These were probably due to me running it in
Python 2 rather than 3, although it has been a few years so I forget the <em>exact</em> issues. Once I had the code to just gather
a few devices of interest I developed code to run this as part of the TITAN system. For example I prepared a function to
ensure that all devices were connected and alerting the riders if any failed to connect if they didn&rsquo;t.</p>
<p>Testing the code for these was some fun. To test the heart rate monitor I wore it and would either hold my breath or begin
hyperventilating to observe a change. As for the power pedals I actually had an exercise bike I would pedal on for testing.
We now have additional ANT USB dongles I could use to simulate the output of a device but I feel that it&rsquo;ll ruin much of the
fun involved in the process.</p>
<h4 id="radio-communication">Radio Communication</h4>
<p>I initially wanted to get some telemetry working with the nRF24 modules I found, I even had some radio libraries ready,
however I didn&rsquo;t have the time to properly develop or test any code related to this so it was never implemented.</p>
<h2 id="assembly-into-titan">Assembly into TITAN</h2>
<p>Assembling the system into TITAN was not as easy as we had anticipated, but still successful.</p>
<p>There was significantly more wiring involved in this than either of my previous projects for the team, much of this was
necessitated by the cameras and displays not being placed near one another. Luckily most of the wiring was able to be routed
within the hollow frame/roll-cage, with the ribbon cables for cameras run along them.</p>
<figure>
<img src="/images/titan-v1-assembly-in-titan.jpg">
<figcaption>My teammate working on installing the electronics into the rear end of TITAN</figcaption>
</figure>
<p>Although tedious, routing the cables wasn&rsquo;t the most problematic. We had issues fitting the TITAN boards nicely around the
vehicle given their size and the ribbon cable between them and their RPis. Each display entailed three separate,
moderately-large boards (RPi, my board, display driver) for a total of nine in TITAN.</p>
<p>My teammate and I had some issues setting up the optical encoder on the rear wheel. Initially we wanted to use a laser based
encoder that would be interrupted by the passing spokes of the brake disk. However after some testing it was found that the
laser would inevitably lose its alignment with the optical sensor. Our solution was to replace the laser with a red LED
since the LED&rsquo;s light was much less directional than the laser and thus could tolerate more misalignment.</p>
<h2 id="outcome">Outcome</h2>
<p>Soon after we installed the system, TITAN went off to the competition (the figure of my teammate installing electronics was
taken September 1st, 2019 - mere days before the team set off to compete). This left little time for me to test the system
in situ.</p>
<p>I was not able to join the team going to compete so I was unable to provide technical support there if it began to misbehave.
I did however prepare a manual with some brief trouble shooting guides for those that did go. Unfortunately I did not
anticipate some of the issues they faced with the program, and instead of addressing them and fixing my system, they elected
to use the system from Eta Prime instead.</p>
<figure>
<img src="/images/eta-prime-video.jpg">
<figcaption>The core of the Eta Prime video system</figcaption>
</figure>
<p>When they returned I collected their feedback and identified several suggestions for the system going forward:</p>
<ul>
<li>One RPi/board pair resulted in a boot loop
<ul>
<li>Likely caused by a poor voltage regulator</li>
</ul>
</li>
<li>The camera feed would flash black periodically, seemingly cutting out.
<ul>
<li>Initially suspected to be the result of loose connections in a vibrating environment</li>
<li>This was later found to be caused by the overlay updating process.</li>
</ul>
</li>
<li>The rear facing camera was useless
<ul>
<li>Perhaps display historical data trends on the rear display instead</li>
<li>A front-facing feed?</li>
</ul>
</li>
<li>Add dedicated power buttons for RPis instead of relying on connecting and disconnecting batteries</li>
<li>Start the camera feed on boot, not debug messages</li>
<li>I should consider using a direct camera-screen setup for the back-up video feed
<ul>
<li>Reduces number of potential failure point</li>
<li>Simplifies circuit</li>
<li>Cheaper?</li>
</ul>
</li>
</ul>

  </section>
  </main>
  
  <footer>
     <a href="http://savobajic.ca/">Savo Bajic's Website</a>
</footer>
</div>

</body>
</html>
